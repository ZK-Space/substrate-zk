# ZK SNARKS Introduction

## Prerequisite(What is ZK SNARKS)
Zero-knowledge proofs were first introduced by Shafi Goldwasser, Silvio Micali and Charles Rackoff. A zero-knowledge proof allows one party, the prover, to convince another party, the verifier, that a given statement is true, without revealing any information beyond the validity of the statement itself. 

A `zkSNARK`(zero-knowledge succinct non-interactive argument of knowledge) is a variant of a zero-knowledge proof that enables a prover to succinctly convince any verifier of the validity of a given statement and achieves computational zero-knowledge without requiring interaction between the prover and any verifier.
> Zero knowledge proof can be divided into two categories:  
>* **Interactive zero knowledge proof**: The prover ùí´ sends data to the verifier ùí±, and the verifier ùí± also needs to send a challenge random number to the prover ùí´. This interaction is similar to that of the TCP/IP protocol. Through multiple interactions, the verifier can verify the correctness of prover.
>* **Non interactive proof**: The prover ùí´ generates a proof and sends it to the verifier ùí±. The challenge random number is obtained by the prover based on the current data hash, and the difficulty of manipulating the challenge random number is the same as that of POW, making the scheme secure. The verifier ùí± only needs to verify consistency. There is no other additional data interaction in this process. Similar to the process where a user sends an ECDSA signature for consensus node consistency verification, the entire process only involves one data transmission.

zkSNARKs can be used to prove and verify, in zero-knowledge, the integrity of computations, expressed as NP statements. A prover with knowledge of the witness for the NP statement can produce a succinct proof that attests to the truth of the NP statement. Anyone can then verify this short proof, which offers the following properties:

* **Zero-knowledge** - the verifier learns nothing from the proof beside the truth of the statement (i.e., the value qux, in the examples above, remains secret).
* **Succinctness** - the proof is short and easy to verify.
* **Non-interactivity**: - the proof is a string (i.e. it does not require back-and-forth interaction between the prover and the verifier).
* **Soundness** - the proof is computationally sound (i.e., it is infeasible to fake a proof of a false NP statement). Such a proof system is also called an argument.
* **Proof of knowledge** - the proof attests not just that the NP statement is true, but also that the prover knows why (e.g., knows a valid qux).

Together, these properties comprise a zkSNARK, which stands for a **Z**ero-**K**nowledge **S**uccinct **N**on-interactive **A**rgument of **K**nowledge.

Some theories mentioned above may be boring, we can use a simple scenario to illustrate ZKSNARK: Alice wants to prove to Bob that a `house(public signal)` belongs to her. How can she prove it to Bob without showing him the `key(private input)` of house? Alice just needs to ask Bob to turn around while she opens the door to the house. Then, she asks Bob to turn back and show him that `the door is now open(statement)`. This proves that the house belongs to Alice. In this process, Alice has not revealed any part related to her key, so it is non-interactive.

In the above scenario, we can return to the NP problem mentioned earlier. For someone without the key (`without a private input`), the problem of opening a door is essentially `an intractable problem in polynomial time`. However, once a known solution is discovered (i.e., the door has been opened), a verifier can `confirm the correctness of this solution in polynomial time`. This is the essence of ZK-SNARKs. Later on, we will delve deeper into this core concept with some slightly more theoretical knowledge.


## How to construct ZK SNARKS?
OKÔºåhere we will explain how to construct ZK SNARKS. You may not have heard of some steps, but it's not important, just take them step by step.

- Generate the CRS
- Construct arithmetic circuits
- Convert circuit to R1CS
- Convert R1CS to QAP
- Generate proof
- Verify proof


## Generate the CRS
In ZKSNARKs, `CRS(Common Reference String)` is a random public parameter generated by a trusted third party and used to verify the correctness of zero-knowledge proofs. CRS is a fixed, publicly known parameter used to verify all zero-knowledge proofs.

The role of CRS in ZKSNARKs is crucial. It is generated by a trusted party and used to decrypt and decode the data in the proof to verify its validity. If the CRS is generated by a malicious party, the entire ZKSNARKs system may become insecure. Therefore, it is essential to ensure that the CRS generation process is secure and cannot be predicted or tampered with by a malicious party.

It is worth noting that generating the CRS is computationally expensive, and its length is usually much longer than the length of the proof itself. Therefore, ZKSNARKs typically employ techniques to reduce the size and cost of generating the CRS, such as using the hash value of the common reference string as the root node and storing the intermediate values of the proof using a Merkle tree to efficiently verify the correctness of the proof.

In addition to the trusted part setup method mentioned above for generating CRS, `Powers of Tau` is also a ceremony used to generate CRS, which can help ensure that the generated CRS is safe and reliable. The ceremony was proposed by the core developers of zkSNARKs in 2017 to address security risks that may exist in the CRS generation process, especially the risk of a man-in-the-middle attack.

The specific process of the "Powers of Tau" ceremony is that participants need to generate random numbers in a specific way according to a specific protocol and contribute them to the CRS generation process. After the participants submit their contributions, the contributions are combined together and verified using cryptographic methods to ensure that the generated CRS is correct and that no one can control the generation process through malicious means.

Due to the widely recognized security of the "Powers of Tau" ceremony, it has become a standard process for generating CRS in many zkSNARKs systems, such as the Bowe-Hopwood-Tessaro (BHT) construction for zk-SNARKs and the zk-SNARKs implementation for the Zcash cryptocurrency, among others.

## Construct arithmetic circuits
The arithmetic circuit in ZKSNARK is a calculation model that transforms inputs into outputs through finite field operations or Boolean circuits, enabling various algorithms such as encryption, hashing, and signing. The arithmetic circuit is one of the key components in implementing zero-knowledge proofs.

In ZKSNARK, the role of the arithmetic circuit is to transform a set of public inputs into a set of private outputs and verify whether these outputs satisfy specific conditions without revealing any information about the inputs. By combining the arithmetic circuit with ZKSNARK, highly secure and private zero-knowledge proofs can be achieved.

The need for arithmetic circuits arises in ZKSNARK proofs because it is required to prove that a statement (such as the answer to a specific question) satisfies certain conditions without revealing any information about the statement. Therefore, a method is needed to verify whether a statement satisfies the conditions without revealing any information. The arithmetic circuit provides such a method by transforming the statement into a set of numbers, and then performing operations on these numbers to verify whether they satisfy the conditions without disclosing the original information.

In conclusion, the arithmetic circuit is an important component in ZKSNARK, providing a secure and private way to verify whether inputs satisfy specific conditions.

## Convert circuit to R1CS
The R1CS(Rank-1 Constraint System) is a mathematical expression used to represent arithmetic circuits. R1CS can transform arithmetic circuits into a set of linear constraints, which can be used to generate zero-knowledge proofs.

The role of R1CS is to act as an intermediate representation, converting arithmetic circuits into a constraint system that can be used to generate proofs. It transforms each gate in the arithmetic circuit into a linear constraint, such as Ax + By + Cz = 0, where A, B, C are constants and x, y, z are input variables. By transforming each gate into a constraint, R1CS represents the arithmetic circuit as a system of linear equations, which can be solved using linear algebra. By solving this system of equations, the proof can be verified for correctness, achieving the goal of zero-knowledge proof.

The main reason for converting arithmetic circuits to R1CS is to simplify the proof generation process. In ZKSNARKs, generating a proof requires transforming the arithmetic circuit into a set of constraint systems and processing them with some specific numbers, such as random numbers. Directly converting the arithmetic circuit into a constraint system may result in a cumbersome proof generation process that requires significant computing resources. Converting arithmetic circuits to R1CS can simplify the proof generation process and make proof generation more efficient.

## Convert R1CS to QAP
In ZKSNARKs, R1CS is a constraint system used to represent arithmetic circuits. However, directly using R1CS for proofs is not practical as it requires a lot of computing resources and memory. R1CS is a way of describing arithmetic circuits where each gate of the circuit is described as a linear constraint. Although this format is intuitive, it can lead to overly complex and inefficient processing and verification.Therefore, to simplify the proof process, we need to further transform R1CS into a more compact form. This is where QAP (Quadratic Arithmetic Program) comes in.

QAP is a more compact representation that converts the linear constraints in R1CS into quadratic constraints, which are more compact and easier to handle, and can be processed using efficient mathematical techniques such as polynomial evaluation.

* **Mapping from R1CS to QAP**: The first step is to map each constraint of R1CS to the format of QAP. For each constraint of R1CS, such as A * B - C = 0, we need to construct three polynomials $A(x)$, $B(x)$, $C(x)$ such that for all i, $A(i) * B(i) - C(i) = 0$.

* **Constructing the target polynomial**: After constructing the polynomials $A(x)$, $B(x)$, $C(x)$, we create a target polynomial $Z(x)$ whose roots include the solution to the R1CS constraint.

* **Constructing auxiliary polynomials**: We then construct two auxiliary polynomials $L(x)$ and $R(x)$. Each term of these polynomials corresponds to a term on the left and right sides (i.e., $A$ and $B$) of the R1CS constraint.

* **Verification**: Finally, we verify that these polynomials satisfy the relation $A(x) * B(x) - C(x) = H(x) * Z(x)$, where $H(x)$ is an auxiliary polynomial. If this relation holds, then we have proved the original R1CS constraint.

By following these steps, we can convert R1CS to QAP. QAP is a more compact representation form that can greatly simplify the proof process and improve the efficiency and scalability of proofs.

## Generate proof
In ZK-SNARKS, the process of generating a proof is typically performed using the proof algorithm of a zero-knowledge proof system, which allows a prover to prove the truth of a statement or assertion to a verifier without revealing any other information about the statement or assertion.

The process of generating a proof includes the following steps:

- **Computing witness**: For a statement that needs to be proven, the prover first needs to compute a solution that satisfies the statement. This solution is also known as a `witness`.

- **Generating QAP**: The prover transforms the statement into an R1CS (Rank 1 Constraint System), and then converts the R1CS into a `QAP` (Quadratic Arithmetic Program).

- **Generating proof**: Using the witness and QAP, the prover generates a proof by performing a series of computations. This `proof` contains elements such as the evaluation of polynomials and values at specific points.

In this process, the key to generating a proof is how the prover constructs the proof. The prover needs to select appropriate random values and use them to calculate some values that satisfy the constraints and generate the proof.

The process of generating a proof is a crucial step in ZKSNARKS, as it determines the security and efficiency of the proof system.

## Verify proof
In ZK SNARKs, the process of verifying a proof typically uses the verification algorithm of a zero-knowledge proof system, which allows a verifier to verify the statement without revealing any other information about the statement or assertion.

The process of verifying a proof includes the following steps:
- Input checking: The verifier checks whether the input conforms to the required format.
- Public reference string checking: The verifier checks whether the common reference string is consistent with the one used to generate the proof.
- Proof verification: The verifier uses the common reference string, the statement, and the proof to verify its correctness. This process typically involves operations on vectors and matrices.
- Output decision: Based on the verification result of the proof, the verifier decides whether to accept the truthfulness of the statement. If the proof passes the verification, the verifier accepts the truthfulness of the statement. Otherwise, the verifier rejects the truthfulness of the statement.