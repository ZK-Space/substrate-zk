#![cfg_attr(not(feature = "std"), no_std)]

pub use pallet::*;

pub mod parser;
pub mod types;
use parser::{parse_proof, parse_vkey};
use types::{ProofStr, VkeyStr};

#[frame_support::pallet]
pub mod pallet {
	use crate::{parse_proof, parse_vkey, ProofStr, VkeyStr};
	use frame_support::pallet_prelude::*;
	use frame_system::pallet_prelude::*;

	use core::str::from_utf8;
	use sp_std::vec::Vec;

	use bellman_verifier::{prepare_verifying_key, verify_proof, VerificationError};
	use bls12_381::Bls12;
	use ff::PrimeField as Fr;

	type PublicSignalStr = Vec<u8>;

	#[pallet::config]
	pub trait Config: frame_system::Config {
		type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;
	}

	#[pallet::pallet]
	#[pallet::without_storage_info]
	pub struct Pallet<T>(_);

	/// Store thr pr
	#[pallet::storage]
	// #[pallet::getter(fn proof_store)]
	pub type Pof<T: Config> = StorageValue<_, ProofStr, ValueQuery>;

	#[pallet::storage]
	// #[pallet::getter(fn vkey_store)]
	pub type Vkey<T: Config> = StorageValue<_, VkeyStr, ValueQuery>;

	#[pallet::storage]
	pub type PubSignal<T: Config> = StorageValue<_, PublicSignalStr, ValueQuery>;

	#[pallet::event]
	#[pallet::generate_deposit(pub(super) fn deposit_event)]
	pub enum Event<T: Config> {
		VerificationKeyStored(T::AccountId, VkeyStr),
		PublicSignalStored(T::AccountId, PublicSignalStr),
		ProofStored(T::AccountId, ProofStr),
		VerificationPassed(T::AccountId),
	}

	#[pallet::error]
	pub enum Error<T> {
		/// If you want to verify the proof, but there is no Verification key
		NoVerificationKey,
		/// Upload none proof(No proof to verify)
		NoProof,
		/// upload none public signal(no public signal to verify)
		NoPublicSignal,
		/// invalid verification key
		InvalidVerificationKey,
		/// invalid public signal
		InvalidPublic,
		/// verification failed with invalid proof
		InvalidProof,
	}

	/// upload the proof generated by the snarkjs(using bls12381 curve) with groth16
	#[pallet::call]
	impl<T: Config> Pallet<T> {
		#[pallet::weight(0)]
		pub fn set_zk_keys(
			origin: OriginFor<T>,
			public_signal: Vec<u8>,
			vk_alpha1: Vec<u8>,
			vk_beta_2: Vec<u8>,
			vk_gamma_2: Vec<u8>,
			vk_delta_2: Vec<u8>,
			vk_ic0: Vec<u8>,
			vk_ic1: Vec<u8>,
		) -> DispatchResult {
			let who = ensure_signed(origin)?;

			let vkey = VkeyStr {
				alpha_1: vk_alpha1,
				beta_2: vk_beta_2,
				gamma_2: vk_gamma_2,
				delta_2: vk_delta_2,
				ic0: vk_ic0,
				ic1: vk_ic1,
			};

			<PubSignal<T>>::put(&public_signal);
			<Vkey<T>>::put(&vkey);

			Self::deposit_event(Event::<T>::PublicSignalStored(who.clone(), public_signal));
			Self::deposit_event(Event::<T>::VerificationKeyStored(who.clone(), vkey));
			Ok(())
		}

		/// verify the proof of snarkjs with groth16(bellman verification)

		// TODO: add a argument with `proof`, we need to pass proof to verify
		// TODO: need to adjust the verification procedure
		#[pallet::weight(0)]
		pub fn verify_proof(
			origin: OriginFor<T>,
			proof_a: Vec<u8>,
			proof_b: Vec<u8>,
			proof_c: Vec<u8>,
		) -> DispatchResult {
			let who = ensure_signed(origin)?;
			let public_signal = PubSignal::<T>::get();
			let vkeystr = Vkey::<T>::get();
			if public_signal.len() == 0 {
				return Err(Error::<T>::NoPublicSignal.into())
			} else if proof_a.is_empty() || proof_b.is_empty() || proof_c.is_empty() {
				return Err(Error::<T>::InvalidProof.into())
			} else if proof_a.is_empty() && proof_b.is_empty() && proof_b.is_empty() {
				return Err(Error::<T>::NoProof.into())
			} else {
				match Some(&vkeystr) {
					Some(VkeyStr { alpha_1: _, beta_2: _, gamma_2: _, delta_2: _, ic0: _, ic1: _ }) => {
						let pof = ProofStr { pi_a: proof_a, pi_b: proof_b, pi_c: proof_c };
						let proof = parse_proof::<Bls12>(pof.clone());
						let vkey = parse_vkey::<Bls12>(vkeystr);

						let pvk = prepare_verifying_key(&vkey);
						// if let 
						let public_str =
							from_utf8(&public_signal).map_err(|_| Error::<T>::InvalidPublic)?;

						// verify the proof
						match verify_proof(
							&pvk,
							&proof,
							&[Fr::from_str_vartime(public_str).unwrap()],
						) {
							Ok(()) => Self::deposit_event(Event::<T>::VerificationPassed(who.clone())),
							Err(e) => {
								match e {
									VerificationError::InvalidVerifyingKey =>
										return Err(Error::<T>::InvalidVerificationKey.into()),
									VerificationError::InvalidProof =>
										return Err(Error::<T>::InvalidProof.into()),
								};
							},
						};
						Self::deposit_event(Event::<T>::ProofStored(who, pof));
					},
					None => {
						return Err(Error::<T>::NoVerificationKey.into())
					},
				}
			}
			Ok(())
		}

		//TODO: verify the proof of bellman with groth16 directly(bellman verification)
		/* 		#[pallet::weight(0)]
		pub fn bellman_verifier(origin: OriginFor<T>) -> DispatchResult{
			let who = ensure_signed(origin)?;
			match verify_proof(&pvk, &proof, &[Fr::from_str_vartime("33").unwrap()]) {
				Ok(()) => Self::deposit_event(Event::<T>::VerificationPassed(who)),
				Err(e) => {
					// Err(Error::<T>::VerificationFailed.into())
					match e {
						VerificationError::InvalidVerifyingKey => Err(Error::<T>::InvalidVerificationKey.into()),
						VerificationError::InvalidProof => Err(Error::<T>::InvalidProof.into()),
					}
					()
				}
			}
			Ok(())
		} */
	}
}
