2a3
> use futures::FutureExt;
4c5
< use sc_client_api::{BlockBackend};
---
> use sc_client_api::{Backend, BlockBackend};
5a7
> use sc_consensus_grandpa::SharedVoterState;
7,9c9
< use sc_finality_grandpa::SharedVoterState;
< use sc_keystore::LocalKeystore;
< use sc_service::{error::Error as ServiceError, Configuration, TaskManager};
---
> use sc_service::{error::Error as ServiceError, Configuration, TaskManager, WarpSyncParams};
10a11
> use sc_transaction_pool_api::OffchainTransactionPoolFactory;
38a40,44
> /// The minimum period of blocks on which justifications will be
> /// imported and generated.
> const GRANDPA_JUSTIFICATION_PERIOD: u32 = 512;
> 
> #[allow(clippy::type_complexity)]
46c52
< 		sc_consensus::DefaultImportQueue<Block, FullClient>,
---
> 		sc_consensus::DefaultImportQueue<Block>,
49c55
< 			sc_finality_grandpa::GrandpaBlockImport<
---
> 			sc_consensus_grandpa::GrandpaBlockImport<
55c61
< 			sc_finality_grandpa::LinkHalf<Block, FullClient, FullSelectChain>,
---
> 			sc_consensus_grandpa::LinkHalf<Block, FullClient, FullSelectChain>,
61,64d66
< 	if config.keystore_remote.is_some() {
< 		return Err(ServiceError::Other("Remote Keystores are not supported.".into()))
< 	}
< 
76,82c78
< 	let executor = NativeElseWasmExecutor::<ExecutorDispatch>::new(
< 		config.wasm_method,
< 		config.default_heap_pages,
< 		config.max_runtime_instances,
< 		config.runtime_cache_size,
< 	);
< 
---
> 	let executor = sc_service::new_native_or_wasm_executor(config);
106c102
< 	let (grandpa_block_import, grandpa_link) = sc_finality_grandpa::block_import(
---
> 	let (grandpa_block_import, grandpa_link) = sc_consensus_grandpa::block_import(
108c104,105
< 		&(client.clone() as Arc<_>),
---
> 		GRANDPA_JUSTIFICATION_PERIOD,
> 		&client,
134a132
> 			compatibility_mode: Default::default(),
149,155d146
< fn remote_keystore(_url: &String) -> Result<Arc<LocalKeystore>, &'static str> {
< 	// FIXME: here would the concrete keystore be built,
< 	//        must return a concrete type (NOT `LocalKeystore`) that
< 	//        implements `CryptoStore` and `SyncCryptoStore`
< 	Err("Remote Keystore not supported.")
< }
< 
157c148
< pub fn new_full(mut config: Configuration) -> Result<TaskManager, ServiceError> {
---
> pub fn new_full(config: Configuration) -> Result<TaskManager, ServiceError> {
163c154
< 		mut keystore_container,
---
> 		keystore_container,
169,179c160,162
< 	if let Some(url) = &config.keystore_remote {
< 		match remote_keystore(url) {
< 			Ok(k) => keystore_container.set_remote_keystore(k),
< 			Err(e) =>
< 				return Err(ServiceError::Other(format!(
< 					"Error hooking up remote keystore for {}: {}",
< 					url, e
< 				))),
< 		};
< 	}
< 	let grandpa_protocol_name = sc_finality_grandpa::protocol_standard_name(
---
> 	let mut net_config = sc_network::config::FullNetworkConfiguration::new(&config.network);
> 
> 	let grandpa_protocol_name = sc_consensus_grandpa::protocol_standard_name(
182a166,168
> 	net_config.add_notification_protocol(sc_consensus_grandpa::grandpa_peers_set_config(
> 		grandpa_protocol_name.clone(),
> 	));
184,188c170
< 	config
< 		.network
< 		.extra_sets
< 		.push(sc_finality_grandpa::grandpa_peers_set_config(grandpa_protocol_name.clone()));
< 	let warp_sync = Arc::new(sc_finality_grandpa::warp_proof::NetworkProvider::new(
---
> 	let warp_sync = Arc::new(sc_consensus_grandpa::warp_proof::NetworkProvider::new(
194c176
< 	let (network, system_rpc_tx,tx_handler_controller,  network_starter) =
---
> 	let (network, system_rpc_tx, tx_handler_controller, network_starter, sync_service) =
196a179
> 			net_config,
202c185,186
< 			warp_sync: Some(warp_sync),
---
> 			warp_sync_params: Some(WarpSyncParams::WithProvider(warp_sync)),
> 			block_relay: None,
206,210c190,206
< 		sc_service::build_offchain_workers(
< 			&config,
< 			task_manager.spawn_handle(),
< 			client.clone(),
< 			network.clone(),
---
> 		task_manager.spawn_handle().spawn(
> 			"offchain-workers-runner",
> 			"offchain-worker",
> 			sc_offchain::OffchainWorkers::new(sc_offchain::OffchainWorkerOptions {
> 				runtime_api_provider: client.clone(),
> 				is_validator: config.role.is_authority(),
> 				keystore: Some(keystore_container.keystore()),
> 				offchain_db: backend.offchain_storage(),
> 				transaction_pool: Some(OffchainTransactionPoolFactory::new(
> 					transaction_pool.clone(),
> 				)),
> 				network_provider: network.clone(),
> 				enable_http_requests: true,
> 				custom_extensions: |_| vec![],
> 			})
> 			.run(client.clone(), task_manager.spawn_handle())
> 			.boxed(),
235c231
< 		keystore: keystore_container.sync_keystore(),
---
> 		keystore: keystore_container.keystore(),
241a238
> 		sync_service: sync_service.clone(),
250c247
< 			transaction_pool,
---
> 			transaction_pool.clone(),
255d251
< 
278,280c274,276
< 				keystore: keystore_container.sync_keystore(),
< 				sync_oracle: network.clone(),
< 				justification_sync_link: network.clone(),
---
> 				keystore: keystore_container.keystore(),
> 				sync_oracle: sync_service.clone(),
> 				justification_sync_link: sync_service.clone(),
283a280
> 				compatibility_mode: Default::default(),
294,310d290
< 	// if the node isn't actively participating in consensus then it doesn't
< 	// need a keystore, regardless of which protocol we use below.
< 	let keystore =
< 		if role.is_authority() { Some(keystore_container.sync_keystore()) } else { None };
< 
< 	let grandpa_config = sc_finality_grandpa::Config {
< 		// FIXME #1578 make this available through chainspec
< 		gossip_duration: Duration::from_millis(333),
< 		justification_period: 512,
< 		name: Some(name),
< 		observer_enabled: false,
< 		keystore,
< 		local_role: role,
< 		telemetry: telemetry.as_ref().map(|x| x.handle()),
< 		protocol_name: grandpa_protocol_name,
< 	};
< 
311a292,307
> 		// if the node isn't actively participating in consensus then it doesn't
> 		// need a keystore, regardless of which protocol we use below.
> 		let keystore = if role.is_authority() { Some(keystore_container.keystore()) } else { None };
> 
> 		let grandpa_config = sc_consensus_grandpa::Config {
> 			// FIXME #1578 make this available through chainspec
> 			gossip_duration: Duration::from_millis(333),
> 			justification_generation_period: GRANDPA_JUSTIFICATION_PERIOD,
> 			name: Some(name),
> 			observer_enabled: false,
> 			keystore,
> 			local_role: role,
> 			telemetry: telemetry.as_ref().map(|x| x.handle()),
> 			protocol_name: grandpa_protocol_name,
> 		};
> 
318c314
< 		let grandpa_config = sc_finality_grandpa::GrandpaParams {
---
> 		let grandpa_config = sc_consensus_grandpa::GrandpaParams {
322c318,319
< 			voting_rule: sc_finality_grandpa::VotingRulesBuilder::default().build(),
---
> 			sync: Arc::new(sync_service),
> 			voting_rule: sc_consensus_grandpa::VotingRulesBuilder::default().build(),
325a323
> 			offchain_tx_pool_factory: OffchainTransactionPoolFactory::new(transaction_pool),
333c331
< 			sc_finality_grandpa::run_grandpa_voter(grandpa_config)?,
---
> 			sc_consensus_grandpa::run_grandpa_voter(grandpa_config)?,
