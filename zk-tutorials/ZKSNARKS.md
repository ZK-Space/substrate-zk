# ZK SNARKS Introduction

## Prerequisite(What is ZK SNARKS)
Zero-knowledge proofs were first introduced by Shafi Goldwasser, Silvio Micali and Charles Rackoff. A zero-knowledge proof allows one party, the prover, to convince another party, the verifier, that a given statement is true, without revealing any information beyond the validity of the statement itself. 

A `zkSNARK`(zero-knowledge succinct non-interactive argument of knowledge) is a variant of a zero-knowledge proof that enables a prover to succinctly convince any verifier of the validity of a given statement and achieves computational zero-knowledge without requiring interaction between the prover and any verifier.
> Zero knowledge proof can be divided into two categories:  
>* **Interactive zero knowledge proof**: The prover ùí´ sends data to the verifier ùí±, and the verifier ùí± also needs to send a challenge random number to the prover ùí´. This interaction is similar to that of the TCP/IP protocol. Through multiple interactions, the verifier can verify the correctness of prover.
>* **Non interactive proof**: The prover ùí´ generates a proof and sends it to the verifier ùí±. The challenge random number is obtained by the prover based on the current data hash, and the difficulty of manipulating the challenge random number is the same as that of POW, making the scheme secure. The verifier ùí± only needs to verify consistency. There is no other additional data interaction in this process. Similar to the process where a user sends an ECDSA signature for consensus node consistency verification, the entire process only involves one data transmission.

zkSNARKs can be used to prove and verify, in zero-knowledge, the integrity of computations, expressed as NP statements. A prover with knowledge of the witness for the NP statement can produce a succinct proof that attests to the truth of the NP statement. Anyone can then verify this short proof, which offers the following properties:

* **Zero-knowledge** - the verifier learns nothing from the proof beside the truth of the statement (i.e., the value qux, in the examples above, remains secret).
* **Succinctness** - the proof is short and easy to verify.
* **Non-interactivity**: - the proof is a string (i.e. it does not require back-and-forth interaction between the prover and the verifier).
* **Soundness** - the proof is computationally sound (i.e., it is infeasible to fake a proof of a false NP statement). Such a proof system is also called an argument.
* **Proof of knowledge** - the proof attests not just that the NP statement is true, but also that the prover knows why (e.g., knows a valid qux).

Together, these properties comprise a zkSNARK, which stands for a Zero-Knowledge Succinct Non-interactive ARgument of Knowledge.

Some theories mentioned above may be boring, we can use a simple scenario to illustrate ZKSNARK: Alice wants to prove to Bob that a `house(public signal)` belongs to her. How can she prove it to Bob without showing him the `key(private input)`? Alice just needs to ask Bob to turn around while she opens the door to the house. Then, she asks Bob to turn back and show him that `the door is now open(statement)`. This proves that the house belongs to Alice. In this process, Alice has not revealed any part related to her key, so it is non-interactive.

With the above scenario, we can go back to the NP problem mentioned earlier. For someone without the key(`without a private input`) to a house, the problem of opening the door to the house is `an intractable problem in polynomial time`. However, once a known solution is discovered (the door has been opened), a verifier can `verify in polynomial time` whether the solution is correct. This is the essence of ZK SNARKS. Later on, we will elaborate on this core idea with some slightly theoretical knowledge.


## How to construct ZK SNARKS?
OKÔºåhere we will explain how to construct ZK SNARKS. You may not have heard of some steps, but it's not important, just take them step by step.

- Generate the CRS
- Construct arithmetic circuits
- Convert circuit to R1CS
- Convert R1CS to QAP
- Generate proof
- Verify proof


## Generate the CRS
In ZKSNARKs, `CRS(Common Reference String)` is a random public parameter generated by a trusted third party and used to verify the correctness of zero-knowledge proofs. CRS is a fixed, publicly known parameter used to verify all zero-knowledge proofs.

The role of CRS in ZKSNARKs is crucial. It is generated by a trusted party and used to decrypt and decode the data in the proof to verify its validity. If the CRS is generated by a malicious party, the entire ZKSNARKs system may become insecure. Therefore, it is essential to ensure that the CRS generation process is secure and cannot be predicted or tampered with by a malicious party.

It is worth noting that generating the CRS is computationally expensive, and its length is usually much longer than the length of the proof itself. Therefore, ZKSNARKs typically employ techniques to reduce the size and cost of generating the CRS, such as using the hash value of the common reference string as the root node and storing the intermediate values of the proof using a Merkle tree to efficiently verify the correctness of the proof.

In addition to the trusted part setup method mentioned above for generating CRS, `Powers of Tau` is also a ceremony used to generate CRS, which can help ensure that the generated CRS is safe and reliable. The ceremony was proposed by the core developers of zkSNARKs in 2017 to address security risks that may exist in the CRS generation process, especially the risk of a man-in-the-middle attack.

The specific process of the "Powers of Tau" ceremony is that participants need to generate random numbers in a specific way according to a specific protocol and contribute them to the CRS generation process. After the participants submit their contributions, the contributions are combined together and verified using cryptographic methods to ensure that the generated CRS is correct and that no one can control the generation process through malicious means.

Due to the widely recognized security of the "Powers of Tau" ceremony, it has become a standard process for generating CRS in many zkSNARKs systems, such as the Bowe-Hopwood-Tessaro (BHT) construction for zk-SNARKs and the zk-SNARKs implementation for the Zcash cryptocurrency, among others.

## Construct arithmetic circuits
The arithmetic circuit in ZKSNARK is a calculation model that transforms inputs into outputs through finite field operations or Boolean circuits, enabling various algorithms such as encryption, hashing, and signing. The arithmetic circuit is one of the key components in implementing zero-knowledge proofs.

In ZKSNARK, the role of the arithmetic circuit is to transform a set of public inputs into a set of private outputs and verify whether these outputs satisfy specific conditions without revealing any information about the inputs. By combining the arithmetic circuit with ZKSNARK, highly secure and private zero-knowledge proofs can be achieved.

The need for arithmetic circuits arises in ZKSNARK proofs because it is required to prove that a statement (such as the answer to a specific question) satisfies certain conditions without revealing any information about the statement. Therefore, a method is needed to verify whether a statement satisfies the conditions without revealing any information. The arithmetic circuit provides such a method by transforming the statement into a set of numbers, and then performing operations on these numbers to verify whether they satisfy the conditions without disclosing the original information.

In conclusion, the arithmetic circuit is an important component in ZKSNARK, providing a secure and private way to verify whether inputs satisfy specific conditions.

## Convert circuit to R1CS
The R1CS(Rank-1 Constraint System) is a mathematical expression used to represent arithmetic circuits. R1CS can transform arithmetic circuits into a set of linear constraints, which can be used to generate zero-knowledge proofs.

The role of R1CS is to act as an intermediate representation, converting arithmetic circuits into a constraint system that can be used to generate proofs. It transforms each gate in the arithmetic circuit into a linear constraint, such as Ax + By + Cz = 0, where A, B, C are constants and x, y, z are input variables. By transforming each gate into a constraint, R1CS represents the arithmetic circuit as a system of linear equations, which can be solved using linear algebra. By solving this system of equations, the proof can be verified for correctness, achieving the goal of zero-knowledge proof.

The main reason for converting arithmetic circuits to R1CS is to simplify the proof generation process. In ZKSNARKs, generating a proof requires transforming the arithmetic circuit into a set of constraint systems and processing them with some specific numbers, such as random numbers. Directly converting the arithmetic circuit into a constraint system may result in a cumbersome proof generation process that requires significant computing resources. Converting arithmetic circuits to R1CS can simplify the proof generation process and make proof generation more efficient.

## Convert R1CS to QAP
In ZKSNARKs, R1CS is a constraint system used to represent arithmetic circuits. However, directly using R1CS for proofs is not practical as it requires a lot of computing resources and memory, and also requires the prover to generate and handle a large amount of random numbers. Therefore, to simplify the proof process, we need to further transform R1CS into a more compact form. This is where QAP (Quadratic Arithmetic Program) comes in.

QAP is a more compact representation that converts the linear constraints in R1CS into quadratic constraints, which are more compact and easier to handle, and can be processed using efficient mathematical techniques such as polynomial evaluation.

The conversion process from R1CS to QAP can be divided into several steps:
- Convert each constraint in R1CS into a quadratic constraint. Specifically, for each constraint in R1CS, such as $Ax + By + Cz = 0$, we can convert it into a quadratic constraint, i.e., $(Ax + By + Cz)(Dx + Ey + Fz) = Q$, where $D$, $E$, $F$, and $Q$ are polynomials to be solved.

- Merge all quadratic constraints into one polynomial. Add all quadratic constraints together and eliminate common variables, obtaining a polynomial in the form of $P(x,y,z) = G(x)H(y) - L(z)$, where $G$, $H$, and $L$ are polynomials to be solved.

- Split the polynomial $P(x,y,z)$ into two polynomials $T(x,y,z)$ and $Z(x)$. During the splitting process, we can group each term in the polynomial $P(x,y,z)$ according to the power of variables, resulting in a combination of polynomials $T(x,y,z)$ and $Z(x)$, where $T(x,y,z)$ only contains high-degree terms of $x$, $y$, and $z$, and $Z(x)$ only contains low-degree terms of $x$.

- Convert the polynomials $T(x,y,z)$ and $Z(x)$ into polynomials in the FFT domain. By using the FFT algorithm, we can convert the polynomials $T(x,y,z)$ and $Z(x)$ into polynomials in the FFT domain, which can be efficiently processed using the properties of the FFT algorithm.

By following these steps, we can convert R1CS to QAP and transform the polynomials $T(x,y,z)$ and $Z(x)$ into polynomials in the FFT domain, enabling efficient processing of polynomial operations using the FFT algorithm. QAP is a more compact representation form that can greatly simplify the proof process and improve the efficiency and scalability of proofs.

## Generate proof
In ZK SNARKS, the process of generating a proof is typically performed using the proof algorithm of a zero-knowledge proof system, which allows a prover to prove the truth of a statement or assertion to a verifier without revealing any other information about the statement or assertion.

The process of generating a proof includes the following steps:

- Input transformation: The statement or assertion is transformed into a set of constraints on a common reference string.
- Proof construction: The prover constructs a proof that satisfies these constraints by selecting appropriate random values and performing calculations.
- Proof verification: The verifier uses the common reference string, the statement or assertion, and the proof to verify the correctness of the proof.

In this process, the key to generating a proof is how the prover constructs the proof. The prover needs to select appropriate random values and use them to calculate some values that satisfy the constraints and generate the proof.

In ZK SNARKS, proof construction typically uses Quadratic Arithmetic Program (QAP), which transforms the statement or assertion into a set of polynomial constraints on the common reference string, which can be used to construct the proof.

The prover uses these polynomial constraints and their random values to calculate other polynomials, and compares these calculation results with the values of some special points. If these comparison results satisfy certain conditions, the prover can generate a proof that satisfies the polynomial constraints.

The process of generating a proof is a crucial step in ZKSNARKS, as it determines the security and efficiency of the proof system.

## Verify proof
In ZK SNARKs, the process of verifying a proof typically uses the verification algorithm of a zero-knowledge proof system, which allows a verifier to verify the statement without revealing any other information about the statement or assertion.

The process of verifying a proof includes the following steps:
- Input checking: The verifier checks whether the input conforms to the required format.
- Public reference string checking: The verifier checks whether the public reference string is the same as the one used in the proof generation process.
- Proof verification: The verifier uses the public reference string, the statement or assertion, and the proof to verify the correctness of the proof. This process typically involves transforming the polynomial constraints into some special vectors and matrices and using some special algorithms for vector and matrix operations.
- Output decision: Based on the result of the proof, the verifier decides whether to accept the truthfulness of the statement or assertion.